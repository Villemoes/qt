diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/abstractrenderer.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/abstractrenderer.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/abstractrenderer.h	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/abstractrenderer.h	2012-02-20 11:37:38.489029279 +0900
@@ -49,6 +49,7 @@
     virtual bool eventFilter(QEvent *) = 0;
     virtual void handlePaint(QPaintEvent *) {}
     virtual bool paintsOnWidget() { return true; } // Controls overlays
+    virtual void handleMove(QMoveEvent *event ) { Q_UNUSED(event); }
 
 protected:
     VideoWidget *m_videoWidget;
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/backend.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/backend.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/backend.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/backend.cpp	2012-02-24 18:07:49.581220761 +0900
@@ -50,6 +50,8 @@
         , m_effectManager(0)
         , m_debugLevel(Warning)
         , m_isValid(false)
+        , m_capsWidth(0)
+        , m_capsHeight(0)
 {
     // Initialise PulseAudio support
     PulseSupport *pulse = PulseSupport::getInstance();
@@ -83,6 +85,18 @@
         debugLevel = 3;
     m_debugLevel = (DebugLevel)debugLevel;
 
+    // Caps width and height for capsfilter in VideoWidget.
+    //   768,432 (16:9) as default.
+    QString capsWidthString = qgetenv("PHONON_GST_CAPS_WIDTH");
+    m_capsWidth = capsWidthString.toInt();
+    if (m_capsWidth == 0)
+        m_capsWidth = 768;
+
+    QString capsHeightString = qgetenv("PHONON_GST_CAPS_HEIGHT");
+    m_capsHeight = capsHeightString.toInt();
+    if (m_capsHeight == 0)
+        m_capsHeight = 432;
+
     if (wasInit) {
         m_isValid = checkDependencies();
         gchar *versionString = gst_version_string();
@@ -180,14 +194,14 @@
     if (acFactory) {
         gst_object_unref(acFactory);
         success = true;
-        // Check if gst-plugins-good is installed
-        GstElementFactory *csFactory = gst_element_factory_find ("videobalance");
-        if (csFactory) {
-            gst_object_unref(csFactory);
-        } else {
-            QString message = tr("Warning: You do not seem to have the package gstreamer0.10-plugins-good installed.\n"
-                                 "          Some video features have been disabled.");
-            qDebug() << message;
+        // Check see if mfw_ipucsc is installed or not
+        GstElementFactory *ipuFactory = gst_element_factory_find("mfw_ipucsc");
+        if (ipuFactory) {
+            gst_object_unref(ipuFactory);
+        }
+        else {
+            QString message = tr("Warning: You do not seem to have the package gst-fsl-plugin installed.\n"
+                                 "          Some Freescale SoC features have been disabled.");
         }
     } else {
         qWarning() << tr("Warning: You do not seem to have the base GStreamer plugins installed.\n"
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/backend.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/backend.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/backend.h	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/backend.h	2012-02-20 11:38:50.289029608 +0900
@@ -78,6 +78,9 @@
     void logMessage(const QString &message, int priority = 2, QObject *obj=0) const;
     bool checkDependencies() const;
 
+    int getCapsWidth() const { return m_capsWidth; }
+    int getCapsHeight() const { return m_capsHeight; }
+
 Q_SIGNALS:
     void objectDescriptionChanged(ObjectDescriptionType);
 
@@ -91,6 +94,8 @@
     EffectManager *m_effectManager;
     DebugLevel m_debugLevel;
     bool m_isValid;
+    int m_capsWidth;
+    int m_capsHeight;
 };
 }
 } // namespace Phonon::Gstreamer
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/devicemanager.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/devicemanager.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/devicemanager.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/devicemanager.cpp	2012-02-21 23:28:07.208963779 +0900
@@ -22,6 +22,8 @@
 #include "videowidget.h"
 #include "glrenderer.h"
 #include "widgetrenderer.h"
+#include "mfwv4lrenderer.h"
+#include "mfwirenderer.h"
 #ifdef Q_WS_X11
 #include "x11renderer.h"
 #endif
@@ -78,6 +80,7 @@
         : QObject(backend)
         , m_backend(backend)
         , m_audioDeviceCounter(0)
+        , m_RendererType(Software)
 {
     QSettings settings(QLatin1String("Trolltech"));
     settings.beginGroup(QLatin1String("Qt"));
@@ -260,18 +263,29 @@
 {
 #if !defined(QT_NO_OPENGL) && !defined(QT_OPENGL_ES)
     if (m_videoSinkWidget == "opengl") {
+        m_RendererType = OpenGL;
         return new GLRenderer(parent);
     } else
 #endif
-    if (m_videoSinkWidget == "software") {
+    if (m_videoSinkWidget == "mfw_v4lsink") {
+        m_RendererType = MFWV4LSink;
+        return new MFWV4LRenderer(parent);
+    }
+    if (m_videoSinkWidget == "mfw_isink") {
+        m_RendererType = MFWISink;
+        return new MFWIRenderer(parent);
+    }
+    else if (m_videoSinkWidget == "software") {
         return new WidgetRenderer(parent);
     }
 #ifdef Q_WS_X11
     else if (m_videoSinkWidget == "xwindow") {
+        m_RendererType = XWindow;
         return new X11Renderer(parent);
     } else {
         GstElementFactory *srcfactory = gst_element_factory_find("ximagesink");
         if (srcfactory) {
+            m_RendererType = XWindow;
             return new X11Renderer(parent);
         }
     }
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/devicemanager.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/devicemanager.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/devicemanager.h	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/devicemanager.h	2012-02-21 23:27:43.515962884 +0900
@@ -48,6 +48,19 @@
 class DeviceManager : public QObject {
     Q_OBJECT
 public:
+    enum RendererTypeEnum {
+        Software        = 0x1,
+        MFWV4LSink      = 0x2,
+        MFWISink        = 0x4,
+        OpenGL          = 0x8,
+        XWindow         = 0x10
+    };
+    Q_DECLARE_FLAGS(RendererType, RendererTypeEnum)
+
+    RendererType getRendererType() const {
+        return m_RendererType;
+    }
+
     DeviceManager(Backend *parent);
     virtual ~DeviceManager();
     const QList<AudioDevice> audioOutputDevices() const;
@@ -75,7 +88,11 @@
     QTimer m_devicePollTimer;
     QByteArray m_audioSink;
     QByteArray m_videoSinkWidget;
+    RendererType m_RendererType;
 };
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(DeviceManager::RendererType)
+
 }
 } // namespace Phonon::Gstreamer
 
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mediaobject.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mediaobject.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mediaobject.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mediaobject.cpp	2012-02-20 20:42:04.292962777 +0900
@@ -34,7 +34,8 @@
 #include <QApplication>
 
 #define ABOUT_TO_FINNISH_TIME 2000
-#define MAX_QUEUE_TIME 20 * GST_SECOND
+#define MAX_QUEUE_BYTES	3840
+#define MAX_QUEUE_TIME	33 * GST_SECOND
 
 QT_BEGIN_NAMESPACE
 
@@ -514,7 +515,9 @@
     // pull-mode access. Also note that the max-size-time are increased to
     // reduce buffer overruns as these are not gracefully handled at the moment.
     m_audioPipe = gst_element_factory_make("queue", NULL);
-    g_object_set(G_OBJECT(m_audioPipe), "max-size-time",  MAX_QUEUE_TIME, (const char*)NULL);
+    g_object_set(G_OBJECT(m_audioPipe), "max-size-time",  0, (const char*)NULL);
+    g_object_set(G_OBJECT(m_audioPipe), "max-size-buffers",  0, (const char*)NULL);
+    g_object_set(G_OBJECT(m_audioPipe), "max-size-bytes",  0, (const char*)NULL);
     gst_bin_add(GST_BIN(m_audioGraph), m_audioPipe);
     GstPad *audiopad = gst_element_get_pad (m_audioPipe, "sink");
     gst_element_add_pad (m_audioGraph, gst_ghost_pad_new ("sink", audiopad));
@@ -526,6 +529,7 @@
     gst_object_sink (GST_OBJECT (m_videoGraph));
 
     m_videoPipe = gst_element_factory_make("queue", NULL);
+    g_object_set(G_OBJECT(m_videoPipe), "max-size-bytes",  MAX_QUEUE_BYTES, (const char*)NULL);
     g_object_set(G_OBJECT(m_videoPipe), "max-size-time", MAX_QUEUE_TIME, (const char*)NULL);
     gst_bin_add(GST_BIN(m_videoGraph), m_videoPipe);
     GstPad *videopad = gst_element_get_pad (m_videoPipe, "sink");
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwirenderer.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwirenderer.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwirenderer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwirenderer.cpp	2012-03-02 11:01:46.802341939 +0900
@@ -0,0 +1,215 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <QtGui/QPainter>
+#include <QMouseEvent>
+#include <QPaintEvent>
+#include <gst/gst.h>
+#include "common.h"
+#include "message.h"
+#include "mediaobject.h"
+#include "qwidgetvideosink.h"
+#include "mfwirenderer.h"
+#include "qrgb.h"
+
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <linux/mxcfb.h>
+
+#define MXCFB_GBL_ALPHA	255
+#define MXCFB_CLR_KEY	0x00000000	// ARGB8888
+
+#ifndef QT_NO_PHONON_VIDEO
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+
+MFWIRenderer::MFWIRenderer(VideoWidget *videoWidget)
+        : AbstractRenderer(videoWidget)
+{
+    videoWidget->backend()->logMessage("Creating mfw_isink renderer");
+
+    QString vsAlpha = qgetenv("VSALPHA");
+    m_vsAlpha = vsAlpha.toInt();
+
+    if ((m_videoSink = gst_element_factory_make ("mfw_isink", NULL)) != NULL) {
+        gst_object_ref (GST_OBJECT (m_videoSink)); //Take ownership
+        gst_object_sink (GST_OBJECT (m_videoSink));
+    }
+
+    // Clear the background with black by default
+    QPalette palette;
+    palette.setColor(QPalette::Background, Qt::black);
+    m_videoWidget->setPalette(palette);
+    m_videoWidget->setAutoFillBackground(true);
+    m_videoWidget->setAttribute(Qt::WA_NoSystemBackground, false);
+    m_videoWidget->setAttribute(Qt::WA_PaintOnScreen, false);
+}
+
+MFWIRenderer::~MFWIRenderer()
+{
+    if (m_videoSink) {
+        gst_object_unref (GST_OBJECT (m_videoSink));
+        m_videoSink = 0;
+    }
+}
+
+void MFWIRenderer::setVideoSize(void)
+{
+    int aj_x, aj_y, wWidth, wHeight, fWidth, fHeight;
+
+    QSize widgetSize = m_videoWidget->size();
+    m_drawFrameRect = m_videoWidget->calculateDrawFrameRect();
+    m_framePos = m_videoWidget->mapToGlobal(QPoint(0,0));
+
+    // The input frame must be multiple of 0x8 because IPU does.
+    wWidth  = widgetSize.width();
+    wHeight = widgetSize.height();
+    fWidth  = m_drawFrameRect.width() & ~0x7;
+    fHeight = m_drawFrameRect.height() & ~0x7;
+
+    // Center the video in the widget
+    aj_x = ((int)(wWidth  / 2.0f)) - ((int)(fWidth  / 2.0f));
+    aj_y = ((int)(wHeight / 2.0f)) - ((int)(fHeight / 2.0f));
+
+    // LCD out
+    g_object_set (G_OBJECT(m_videoSink), "display", "LCD", (const char *)NULL);
+#if 1	/* why a movie view is not resizing ? */
+    g_object_set (G_OBJECT(m_videoSink), "axis-left", (aj_x + m_framePos.x()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "axis-top",  (aj_y + m_framePos.y()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-width", fWidth, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-height", fHeight, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-config", 1, (const char *)NULL);
+#endif	/* why a movie view is not resizing ? */
+
+    // TV out
+    g_object_set (G_OBJECT(m_videoSink), "display-1", "TV", (const char *)NULL);
+#if 0	/* why a movie view is not resizing ? */
+    g_object_set (G_OBJECT(m_videoSink), "axis-left-1", (aj_x + m_framePos.x()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "axis-top-1",  (aj_y + m_framePos.y()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-width-1", fWidth, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-height-1", fHeight, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-config-1", 1, (const char *)NULL);
+#endif	/* why a movie view is not resizing ? */
+
+}
+
+void MFWIRenderer::handleMediaNodeEvent(const MediaNodeEvent *event)
+{
+    Q_UNUSED(event);
+}
+
+void MFWIRenderer::handlePaint(QPaintEvent * event)
+{
+    Q_UNUSED(event);
+    QPainter painter(m_videoWidget);
+    painter.fillRect(m_videoWidget->rect(), m_videoWidget->palette().background());
+}
+
+int MFWIRenderer::setOverlay(void)
+{
+    struct mxcfb_color_key colorKey;
+    struct mxcfb_gbl_alpha gblAlpha;
+    int fd;
+    int ret = 0;
+//    const char *devname[2] = { "/dev/fb0", "/dev/fb1", (const char *)NULL };
+    const char *devname[2] = { "/dev/fb0", (const char *)NULL };
+
+    if (m_vsAlpha != 0)
+        return 0;	/* local alpha was set ! */
+
+    for (int i = 0; devname[i] != (const char *)NULL; i++) {
+        if ((fd = open(devname[i], O_RDWR, 0)) < 0) {
+            m_videoWidget->backend()->logMessage("Unable to open /dev/fb0");
+            ret = -1;
+            goto quit;
+        }
+    
+        gblAlpha.alpha  = MXCFB_GBL_ALPHA;
+        gblAlpha.enable = 1;	/* turn on */
+        if (ioctl(fd, MXCFB_SET_GBL_ALPHA, &gblAlpha) < 0) {
+            m_videoWidget->backend()->logMessage("Error in applying Global Alpha");
+        }
+
+        colorKey.color_key = MXCFB_CLR_KEY & 0x00ffffff;
+        colorKey.enable    = 1;	/* turn on */
+        if (ioctl(fd, MXCFB_SET_CLR_KEY, &colorKey) < 0) {
+            m_videoWidget->backend()->logMessage("Error in applying Color Key");
+            ret = -1;
+        }
+
+        close(fd);
+    }
+
+quit:
+    return ret;
+}
+
+void MFWIRenderer::handleMove(QMoveEvent *event)
+{
+    Q_UNUSED(event);
+
+    if (m_framePos != m_videoWidget->mapToGlobal(QPoint(0,0)))
+        setVideoSize();
+
+}
+
+bool MFWIRenderer::eventFilter(QEvent * event)
+{
+    if (event->type() == QEvent::Show) {
+        setOverlay();
+        return true;
+    }
+    else if (event->type() == QEvent::Resize) {
+        setVideoSize();
+        return true;
+    }
+
+    if (m_framePos != m_videoWidget->mapToGlobal(QPoint(0,0)))
+        setVideoSize();
+
+    return false;
+}
+
+void MFWIRenderer::aspectRatioChanged(Phonon::VideoWidget::AspectRatio)
+{
+    setVideoSize();
+}
+
+void MFWIRenderer::scaleModeChanged(Phonon::VideoWidget::ScaleMode)
+{
+    setVideoSize();
+}
+
+void MFWIRenderer::movieSizeChanged(const QSize &movieSize)
+{
+    Q_UNUSED(movieSize);
+    setVideoSize();
+}
+
+}
+} //namespace Phonon::Gstreamer
+
+QT_END_NAMESPACE
+#endif //QT_NO_PHONON_VIDEO
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwirenderer.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwirenderer.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwirenderer.h	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwirenderer.h	2012-02-24 18:10:45.749220113 +0900
@@ -0,0 +1,63 @@
+/*  
+
+    Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef Phonon_GSTREAMER_MFWIRENDERER_H
+#define Phonon_GSTREAMER_MFWIRENDERER_H
+
+#include "videowidget.h"
+#include "common.h"
+
+#ifndef QT_NO_PHONON_VIDEO
+QT_BEGIN_NAMESPACE
+
+class QString;
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+
+class MFWIRenderer : public AbstractRenderer
+{
+public:
+    MFWIRenderer(VideoWidget *videoWidget);
+    ~MFWIRenderer();
+
+    bool eventFilter(QEvent * event);
+    void handlePaint(QPaintEvent *paintEvent);
+    void handleMediaNodeEvent(const MediaNodeEvent *event);
+    QRect drawFrameRect() const { return m_drawFrameRect; }
+    void aspectRatioChanged(Phonon::VideoWidget::AspectRatio aspectRatio);
+    void scaleModeChanged(Phonon::VideoWidget::ScaleMode scaleMode);
+    void movieSizeChanged(const QSize &movieSize);
+    void setVideoSize();
+    int setOverlay();
+    void handleMove(QMoveEvent * event);
+
+private:
+    void paintEvent(QPaintEvent * event);
+    QRect m_drawFrameRect;
+    QPoint m_framePos;
+    int m_vsAlpha;
+};
+
+}
+} //namespace Phonon::Gstreamer
+
+QT_END_NAMESPACE
+#endif //QT_NO_PHONON_VIDEO
+#endif // Phonon_GSTREAMER_MFWIRENDERER_H
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.cpp	2012-03-02 11:01:58.450288054 +0900
@@ -0,0 +1,190 @@
+/*  This file is part of the KDE project.
+
+    Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <QtGui/QPainter>
+#include <QMouseEvent>
+#include <QPaintEvent>
+#include <gst/gst.h>
+#include "common.h"
+#include "message.h"
+#include "mediaobject.h"
+#include "qwidgetvideosink.h"
+#include "mfwv4lrenderer.h"
+#include "qrgb.h"
+
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <linux/mxcfb.h>
+
+#define MXCFB_GBL_ALPHA	255
+#define MXCFB_CLR_KEY	0x00000000	// ARGB8888
+
+#ifndef QT_NO_PHONON_VIDEO
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+
+MFWV4LRenderer::MFWV4LRenderer(VideoWidget *videoWidget)
+        : AbstractRenderer(videoWidget)
+{
+    videoWidget->backend()->logMessage("Creating mfw_v4lsink renderer");
+    if ((m_videoSink = gst_element_factory_make ("mfw_v4lsink", NULL)) != NULL) {
+        gst_object_ref (GST_OBJECT (m_videoSink)); //Take ownership
+        gst_object_sink (GST_OBJECT (m_videoSink));
+    }
+
+    // Clear the background with black by default
+    QPalette palette;
+    palette.setColor(QPalette::Background, Qt::black);
+    m_videoWidget->setPalette(palette);
+    m_videoWidget->setAutoFillBackground(true);
+    m_videoWidget->setAttribute(Qt::WA_NoSystemBackground, false);
+    m_videoWidget->setAttribute(Qt::WA_PaintOnScreen, false);
+}
+
+MFWV4LRenderer::~MFWV4LRenderer()
+{
+    if (m_videoSink) {
+        gst_object_unref (GST_OBJECT (m_videoSink));
+        m_videoSink = 0;
+    }
+}
+
+void MFWV4LRenderer::setVideoSize(void)
+{
+    int aj_x, aj_y, wWidth, wHeight, fWidth, fHeight;
+
+    QSize widgetSize = m_videoWidget->size();
+    m_drawFrameRect = m_videoWidget->calculateDrawFrameRect();
+    m_framePos = m_videoWidget->mapToGlobal(QPoint(0,0));
+
+    // The input frame must be multiple of 0x8 because IPU does.
+    wWidth  = widgetSize.width();
+    wHeight = widgetSize.height();
+    fWidth  = m_drawFrameRect.width() & ~0x7;
+    fHeight = m_drawFrameRect.height() & ~0x7;
+
+    // Center the video in the widget
+    aj_x = ((int)(wWidth  / 2.0f)) - ((int)(fWidth  / 2.0f));
+    aj_y = ((int)(wHeight / 2.0f)) - ((int)(fHeight / 2.0f));
+
+    g_object_set (G_OBJECT(m_videoSink), "axis-left", (aj_x + m_framePos.x()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "axis-top",  (aj_y + m_framePos.y()), (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-width", fWidth, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "disp-height", fHeight, (const char *)NULL);
+    g_object_set (G_OBJECT(m_videoSink), "setpara", 1, (const char *)NULL);
+
+}
+
+void MFWV4LRenderer::handleMediaNodeEvent(const MediaNodeEvent *event)
+{
+    Q_UNUSED(event);
+}
+
+void MFWV4LRenderer::handlePaint(QPaintEvent * event)
+{
+    Q_UNUSED(event);
+    QPainter painter(m_videoWidget);
+    painter.fillRect(m_videoWidget->rect(), m_videoWidget->palette().background());
+}
+
+int MFWV4LRenderer::setOverlay(void)
+{
+    struct mxcfb_color_key colorKey;
+    struct mxcfb_gbl_alpha gblAlpha;
+    int fd;
+    int ret = 0;
+
+    if ((fd = open("/dev/fb0", O_RDWR, 0)) < 0) {
+        m_videoWidget->backend()->logMessage("Unable to open /dev/fb0");
+        ret = -1;
+        goto quit;
+    }
+    
+    gblAlpha.alpha  = MXCFB_GBL_ALPHA;
+    gblAlpha.enable = 1;	/* turn on */
+    if (ioctl(fd, MXCFB_SET_GBL_ALPHA, &gblAlpha) < 0) {
+        m_videoWidget->backend()->logMessage("Error in applying Global Alpha");
+    }
+
+    colorKey.color_key = MXCFB_CLR_KEY & 0x00ffffff;
+    colorKey.enable    = 1;	/* turn on */
+    if (ioctl(fd, MXCFB_SET_CLR_KEY, &colorKey) < 0) {
+        m_videoWidget->backend()->logMessage("Error in applying Color Key");
+        ret = -1;
+    }
+
+    close(fd);
+
+quit:
+    return ret;
+}
+
+void MFWV4LRenderer::handleMove(QMoveEvent *event)
+{
+    Q_UNUSED(event);
+
+    if (m_framePos != m_videoWidget->mapToGlobal(QPoint(0,0)))
+        setVideoSize();
+
+}
+
+bool MFWV4LRenderer::eventFilter(QEvent * event)
+{
+    if (event->type() == QEvent::Show) {
+        setOverlay();
+        return true;
+    }
+    else if (event->type() == QEvent::Resize) {
+        setVideoSize();
+        return true;
+    }
+
+    if (m_framePos != m_videoWidget->mapToGlobal(QPoint(0,0)))
+        setVideoSize();
+
+    return false;
+}
+
+void MFWV4LRenderer::aspectRatioChanged(Phonon::VideoWidget::AspectRatio)
+{
+    setVideoSize();
+}
+
+void MFWV4LRenderer::scaleModeChanged(Phonon::VideoWidget::ScaleMode)
+{
+    setVideoSize();
+}
+
+void MFWV4LRenderer::movieSizeChanged(const QSize &movieSize)
+{
+    Q_UNUSED(movieSize);
+    setVideoSize();
+}
+
+}
+} //namespace Phonon::Gstreamer
+
+QT_END_NAMESPACE
+#endif //QT_NO_PHONON_VIDEO
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.h	1970-01-01 09:00:00.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/mfwv4lrenderer.h	2012-02-21 23:25:08.040963695 +0900
@@ -0,0 +1,62 @@
+/*  
+
+    Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+
+    This library is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 2.1 or 3 of the License.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef Phonon_GSTREAMER_MFWV4LRENDERER_H
+#define Phonon_GSTREAMER_MFWV4LRENDERER_H
+
+#include "videowidget.h"
+#include "common.h"
+
+#ifndef QT_NO_PHONON_VIDEO
+QT_BEGIN_NAMESPACE
+
+class QString;
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+
+class MFWV4LRenderer : public AbstractRenderer
+{
+public:
+    MFWV4LRenderer(VideoWidget *videoWidget);
+    ~MFWV4LRenderer();
+
+    bool eventFilter(QEvent * event);
+    void handlePaint(QPaintEvent *paintEvent);
+    void handleMediaNodeEvent(const MediaNodeEvent *event);
+    QRect drawFrameRect() const { return m_drawFrameRect; }
+    void aspectRatioChanged(Phonon::VideoWidget::AspectRatio aspectRatio);
+    void scaleModeChanged(Phonon::VideoWidget::ScaleMode scaleMode);
+    void movieSizeChanged(const QSize &movieSize);
+    void setVideoSize();
+    int setOverlay();
+    void handleMove(QMoveEvent * event);
+
+private:
+    void paintEvent(QPaintEvent * event);
+    QRect m_drawFrameRect;
+    QPoint m_framePos;
+};
+
+}
+} //namespace Phonon::Gstreamer
+
+QT_END_NAMESPACE
+#endif //QT_NO_PHONON_VIDEO
+#endif // Phonon_GSTREAMER_MFWV4LRENDERER_H
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/qwidgetvideosink.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/qwidgetvideosink.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/qwidgetvideosink.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/qwidgetvideosink.cpp	2012-02-20 11:39:36.089028695 +0900
@@ -100,7 +100,8 @@
                                             "framerate = (fraction) [ 0, MAX ], "
                                             "width = (int) [ 1, MAX ], "
                                             "height = (int) [ 1, MAX ],"
-                                            "bpp = (int) 32"));
+                                            "bpp = (int) 16"));
+//                                            "bpp = (int) 32"));
 
 static GstStaticPadTemplate template_factory_rgb =
     GST_STATIC_PAD_TEMPLATE("sink",
@@ -110,7 +111,8 @@
                                             "framerate = (fraction) [ 0, MAX ], "
                                             "width = (int) [ 1, MAX ], "
                                             "height = (int) [ 1, MAX ],"
-                                            "bpp = (int) 32"));
+                                            "bpp = (int) 16"));
+//                                            "bpp = (int) 32"));
 
 template <VideoFormat FMT>
 struct template_factory;
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/videowidget.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/videowidget.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/videowidget.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/videowidget.cpp	2012-02-22 15:35:32.485220326 +0900
@@ -31,10 +31,14 @@
 
 #include "glrenderer.h"
 #include "widgetrenderer.h"
+#include "mfwv4lrenderer.h"
+#include "mfwirenderer.h"
 #ifdef Q_WS_X11
 #include "x11renderer.h"
 #endif
 
+#define MAX_QUEUE_BYTES	3840
+
 #ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
@@ -55,6 +59,7 @@
     m_saturation(0.0),
     m_scaleMode(Phonon::VideoWidget::FitInView),
     m_videoBalance(0),
+    m_videofilter(0),
     m_colorspace(0),
     m_videoplug(0)
 {
@@ -84,47 +89,64 @@
     gst_object_ref (GST_OBJECT (m_videoBin)); //Take ownership
     gst_object_sink (GST_OBJECT (m_videoBin));
 
-    //The videoplug element is the final element before the pluggable videosink
-    m_videoplug = gst_element_factory_make ("identity", NULL);
-
-    //Colorspace ensures that the output of the stream matches the input format accepted by our video sink
-    m_colorspace = gst_element_factory_make ("ffmpegcolorspace", NULL);
+    // mfw_v4lsink and mfw_isink renderer
+    if (m_backend->deviceManager()->getRendererType() & (DeviceManager::MFWV4LSink | DeviceManager::MFWISink)) {
+        gst_bin_add_many (GST_BIN (m_videoBin), videoSink, NULL);
+        GstPad *videoPad = gst_element_get_pad (videoSink, "sink");
+        gst_element_add_pad (m_videoBin, gst_ghost_pad_new ("sink", videoPad));
+        gst_object_unref (videoPad);
+    
+#ifndef Q_WS_QPA
+        QWidget *parentWidget = qobject_cast<QWidget*>(parent());
+        if (parentWidget)
+            parentWidget->winId();  // Due to some existing issues with alien in 4.4,
+                                    //  we must currently force the creation of a parent widget.
+#endif
 
-    //Video scale is used to prepare the correct aspect ratio and scale.
-    GstElement *videoScale = gst_element_factory_make ("videoscale", NULL);
+        m_isValid = true; //initialization ok, accept input
 
-    //We need a queue to support the tee from parent node
-    GstElement *queue = gst_element_factory_make ("queue", NULL);
-
-    if (queue && m_videoBin && videoScale && m_colorspace && videoSink && m_videoplug) {
-        //Ensure that the bare essentials are prepared
-        gst_bin_add_many (GST_BIN (m_videoBin), queue, m_colorspace, m_videoplug, videoScale, videoSink, (const char*)NULL);
-        bool success = false;
-        //Video balance controls color/sat/hue in the YUV colorspace
-        m_videoBalance = gst_element_factory_make ("videobalance", NULL);
-        if (m_videoBalance) {
-            // For video balance to work we have to first ensure that the video is in YUV colorspace,
-            // then hand it off to the videobalance filter before finally converting it back to RGB.
-            // Hence we nede a videoFilter to convert the colorspace before and after videobalance
-            GstElement *m_colorspace2 = gst_element_factory_make ("ffmpegcolorspace", NULL);
-            gst_bin_add_many(GST_BIN(m_videoBin), m_videoBalance, m_colorspace2, (const char*)NULL);
-            success = gst_element_link_many(queue, m_colorspace, m_videoBalance, m_colorspace2, videoScale, m_videoplug, videoSink, (const char*)NULL);
-        } else {
-            //If video balance is not available, just connect to sink directly
-            success = gst_element_link_many(queue, m_colorspace, videoScale, m_videoplug, videoSink, (const char*)NULL);
+    }
+    // software renderer
+    else {
+        //The videoplug element is the final element before the pluggable videosink
+        m_videoplug = gst_element_factory_make ("identity", NULL);
+
+        // make screen size limit to WVGA
+        m_videofilter = gst_element_factory_make ("capsfilter", NULL);
+        if (m_videofilter) {
+            GstCaps *videoCaps = gst_caps_new_simple (
+                                   "video/x-raw-rgb", 
+                                   "width", G_TYPE_INT, m_backend->getCapsWidth(), 
+                                   "height", G_TYPE_INT, m_backend->getCapsHeight(), 
+                                   NULL);
+            g_object_set (G_OBJECT(m_videofilter), "caps", videoCaps, NULL);
+            gst_caps_unref(videoCaps);
         }
 
-        if (success) {
-            GstPad *videopad = gst_element_get_pad (queue, "sink");
-            gst_element_add_pad (m_videoBin, gst_ghost_pad_new ("sink", videopad));
-            gst_object_unref (videopad);
+        //Colorspace ensures that the output of the stream matches the input format accepted by our video sink
+        m_colorspace = gst_element_factory_make ("mfw_ipucsc", NULL);
+
+        //We need a queue to support the tee from parent node
+        GstElement *queue = gst_element_factory_make ("queue", NULL);
+        g_object_set(G_OBJECT(queue), "max-size-bytes",  MAX_QUEUE_BYTES, (const char*)NULL);
+
+        if (queue && m_videoBin && m_colorspace && videoSink && m_videoplug && m_videofilter) {
+            // Ensure that the bare essentials are prepared
+            gst_bin_add_many (GST_BIN (m_videoBin), queue, m_colorspace, m_videofilter, m_videoplug, videoSink, (const char*)NULL);
+
+            // Connect to sink
+            if (gst_element_link_many(queue, m_colorspace, m_videofilter, m_videoplug, videoSink, (const char*)NULL)) {
+                GstPad *videopad = gst_element_get_pad (queue, "sink");
+                gst_element_add_pad (m_videoBin, gst_ghost_pad_new ("sink", videopad));
+                gst_object_unref (videopad);
 #ifndef Q_WS_QPA
-            QWidget *parentWidget = qobject_cast<QWidget*>(parent());
-            if (parentWidget)
-                parentWidget->winId();  // Due to some existing issues with alien in 4.4,
-                                        //  we must currently force the creation of a parent widget.
+                QWidget *parentWidget = qobject_cast<QWidget*>(parent());
+                if (parentWidget)
+                    parentWidget->winId();  // Due to some existing issues with alien in 4.4,
+                                            //  we must currently force the creation of a parent widget.
 #endif
-            m_isValid = true; //initialization ok, accept input
+                m_isValid = true; //initialization ok, accept input
+            }
         }
     }
 }
@@ -135,6 +157,15 @@
     m_renderer->handlePaint(event);
 }
 
+void VideoWidget::moveEvent(QMoveEvent *event)
+{
+    // mfw_v4lsink renderer
+    if (m_backend->deviceManager()->getRendererType() & DeviceManager::MFWV4LSink) {
+        Q_ASSERT(m_renderer);
+        m_renderer->handleMove(event);
+    }
+}
+
 void VideoWidget::setVisible(bool val) {
     Q_ASSERT(m_renderer);
 
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/videowidget.h qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/videowidget.h
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/videowidget.h	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/videowidget.h	2012-02-20 11:42:09.561028887 +0900
@@ -65,6 +65,7 @@
     qreal saturation() const;
     void setSaturation(qreal);
     void setMovieSize(const QSize &size);
+    void moveEvent(QMoveEvent *event);
     QSize sizeHint() const;
     QRect scaleToAspect(QRect srcRect, int w, int h) const;
     QRect calculateDrawFrameRect() const;
@@ -96,6 +97,7 @@
     Phonon::VideoWidget::ScaleMode m_scaleMode;
 
     GstElement *m_videoBalance;
+    GstElement *m_videofilter;
     GstElement *m_colorspace;
     GstElement *m_videoplug;
 };
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp	2012-02-20 12:11:04.505029768 +0900
@@ -91,8 +91,9 @@
 
     m_frame = QImage(); 
     {
-        m_frame = QImage((uchar *)array.constData(), w, h, QImage::Format_RGB32);
-    }
+        m_frame = QImage((uchar *)array.constData(), w, h, QImage::Format_RGB16);
+//        m_frame = QImage((uchar *)array.constData(), w, h, QImage::Format_RGB32);
+}
 
     m_array = array;
     m_width = w;
@@ -126,7 +127,7 @@
     return m_frame;
 }
 
-void WidgetRenderer::handlePaint(QPaintEvent *event)
+void WidgetRenderer::handlePaint(QPaintEvent * event)
 {
     Q_UNUSED(event);
     QPainter painter(m_videoWidget);
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/x11renderer.cpp qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/x11renderer.cpp
--- qt-everywhere-opensource-src-4.8.0/src/3rdparty/phonon/gstreamer/x11renderer.cpp	2011-12-08 14:06:03.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/3rdparty/phonon/gstreamer/x11renderer.cpp	2012-02-21 23:30:07.808961804 +0900
@@ -83,25 +83,37 @@
 
 GstElement* X11Renderer::createVideoSink()
 {
-    GstElement *videoSink = gst_element_factory_make ("xvimagesink", NULL);
-    if (videoSink) {
-        // Check if the xv sink is usable
-        if (gst_element_set_state(videoSink, GST_STATE_READY) != GST_STATE_CHANGE_SUCCESS) {
-            gst_object_unref(GST_OBJECT(videoSink));
-            videoSink = 0;
-        } else {
-            // Note that this should not really be necessary as these are
-            // default values, though under certain conditions values are retained
-            // even between application instances. (reproducible on 0.10.16/Gutsy)
-            g_object_set(G_OBJECT(videoSink), "brightness", 0, (const char*)NULL);
-            g_object_set(G_OBJECT(videoSink), "contrast", 0, (const char*)NULL);
-            g_object_set(G_OBJECT(videoSink), "hue", 0, (const char*)NULL);
-            g_object_set(G_OBJECT(videoSink), "saturation", 0, (const char*)NULL);
+    GstElement *videoSink;
+    // mfw_v4lsink renderer
+    if (m_videoWidget->backend()->deviceManager()->getRendererType() & DeviceManager::MFWV4LSink) {
+        videoSink = gst_element_factory_make ("mfw_v4lsink", NULL);
+    }
+    // mfw_isink renderer
+    else if (m_videoWidget->backend()->deviceManager()->getRendererType() & DeviceManager::MFWISink) {
+        videoSink = gst_element_factory_make ("mfw_isink", NULL);
+    }
+    else {
+        videoSink = gst_element_factory_make ("xvimagesink", NULL);
+        if (videoSink) {
+            // Check if the xv sink is usable
+            if (gst_element_set_state(videoSink, GST_STATE_READY) != GST_STATE_CHANGE_SUCCESS) {
+                gst_object_unref(GST_OBJECT(videoSink));
+                videoSink = 0;
+            } else {
+                // Note that this should not really be necessary as these are
+                // default values, though under certain conditions values are retained
+                // even between application instances. (reproducible on 0.10.16/Gutsy)
+                g_object_set(G_OBJECT(videoSink), "brightness", 0, (const char*)NULL);
+                g_object_set(G_OBJECT(videoSink), "contrast", 0, (const char*)NULL);
+                g_object_set(G_OBJECT(videoSink), "hue", 0, (const char*)NULL);
+                g_object_set(G_OBJECT(videoSink), "saturation", 0, (const char*)NULL);
+            }
         }
-    }
 
-    if (!videoSink)
-        videoSink = gst_element_factory_make ("ximagesink", NULL);
+        if (!videoSink)
+            videoSink = gst_element_factory_make ("ximagesink", NULL);
+
+    }
 
     gst_object_ref (GST_OBJECT (videoSink)); //Take ownership
     gst_object_sink (GST_OBJECT (videoSink));
diff --exclude CVS --exclude .git -uNr qt-everywhere-opensource-src-4.8.0/src/plugins/phonon/gstreamer/gstreamer.pro qt-everywhere-opensource-src-4.8.0.modified/src/plugins/phonon/gstreamer/gstreamer.pro
--- qt-everywhere-opensource-src-4.8.0/src/plugins/phonon/gstreamer/gstreamer.pro	2011-12-08 14:06:02.000000000 +0900
+++ qt-everywhere-opensource-src-4.8.0.modified/src/plugins/phonon/gstreamer/gstreamer.pro	2012-02-21 23:43:38.932961959 +0900
@@ -26,6 +26,8 @@
  $$PHONON_GSTREAMER_DIR/mediaobject.h \
  $$PHONON_GSTREAMER_DIR/medianode.h \
  $$PHONON_GSTREAMER_DIR/medianodeevent.h \
+ $$PHONON_GSTREAMER_DIR/mfwv4lrenderer.h \
+ $$PHONON_GSTREAMER_DIR/mfwirenderer.h \
  $$PHONON_GSTREAMER_DIR/widgetrenderer.h \
  $$PHONON_GSTREAMER_DIR/videowidget.h \
  $$PHONON_GSTREAMER_DIR/glrenderer.h \
@@ -51,6 +53,8 @@
  $$PHONON_GSTREAMER_DIR/medianodeevent.cpp \
  $$PHONON_GSTREAMER_DIR/mediaobject.cpp \
  $$PHONON_GSTREAMER_DIR/message.cpp \
+ $$PHONON_GSTREAMER_DIR/mfwv4lrenderer.cpp \
+ $$PHONON_GSTREAMER_DIR/mfwirenderer.cpp \
  $$PHONON_GSTREAMER_DIR/phononsrc.cpp \
  $$PHONON_GSTREAMER_DIR/qwidgetvideosink.cpp \
  $$PHONON_GSTREAMER_DIR/streamreader.cpp \
